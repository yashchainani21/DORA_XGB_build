import pandas as pd
import random
import csv
import os
from minedatabase.pickaxe import Pickaxe
from featurizations import featurizations
from preprocessing import preprocessing
from typing import Dict, List, Union
from collections import Counter

# Checked and tested
def select_rule_for_expansion(mapped_rule: str, gen_rules_filepath: str) -> str:
    """
    Selects a specific rule for expansion based on the 'mapped_rule' parameter and saves it to a TSV file.

    This function filters a dataframe of reaction rules loaded from a TSV file ('gen_rules_filepath'),
    and fings the rule that matches the input 'mapped_rule'. The matching rule is then written to a new TSV file
    in a predefined directory '../data/interim/rules_for_pickaxe/'. The path to the newly created file
    is returned. If a.tsv file for this rule already exists, simply return the filepath to the existing file

    Parameters:
    - mapped_rule (str): The name of the rule to be selected for expansion.
    - gen_rules_filepath (str): The file path for the TSV file containing the general rules.

    Returns:
    - str: The file path of the TSV file where the selected rule is saved.

    Note:
    - The function assumes the existence of '../data/interim/rules_for_pickaxe/' directory.
    - The input TSV file should have at least the columns 'Name'.
    """
    path_for_single_rule_input = f"../data/interim/rules_for_pickaxe/{mapped_rule}.tsv"

    # check if the file already exists
    # if it does, no need to create a new file and simply return the filepath
    # aside from saving problems with multiple cores in parallel writing to the same filepath, this is easier on memory
    if os.path.exists(path_for_single_rule_input):
        return path_for_single_rule_input

    else:
        rules_df = pd.read_csv(gen_rules_filepath, delimiter="\t")  # read in the generalized reaction rule
        selected_rule_df = rules_df[rules_df["Name"] == mapped_rule]  # extract the reaction rule of the mapped reaction
        selected_rule_df.to_csv(path_for_single_rule_input, sep="\t")  # save this mapped rule ONLY as a .tsv file
        return path_for_single_rule_input

# Checked and tested
def create_tsv_for_input_cpd(input_cpd_SMILES: str) -> str:
    """
    Create a TSV file for a compound to input into Pickaxe. Ensures that each input compound/precursor
    has a unique filename based on a sanitized version of the SMILES string or, if that's too long,
    use a random hash. This approach aims to prevent issues with filename restrictions and ensure uniqueness.
    If a .tsv filepath for this input compound already exists, simply return the filepath to this existing compound

    Parameters:
    - input_cpd_SMILES (str): The name of the rule to be selected for expansion.

    Returns:
    - str: The file path of the TSV file where the selected compound is saved.
    """

    input_cpd_filepath = f"../data/interim/cpds_for_pickaxe/{input_cpd_SMILES}.tsv"

    # Check if the file already exists
    if not os.path.exists(input_cpd_filepath):
        try:
            with open(input_cpd_filepath, "wt") as out_file:
                tsv_writer = csv.writer(out_file, delimiter="\t")
                tsv_writer.writerow(["id", "smiles"])
                tsv_writer.writerow([input_cpd_SMILES, input_cpd_SMILES])
            return input_cpd_filepath

        # if filename is too long, use a random hash as filename
        except OSError:
            cpd_ID = str(random.getrandbits(128))
            input_cpd_filepath = f"../data/interim/cpds_for_pickaxe/{cpd_ID}.tsv"
            with open(input_cpd_filepath, "wt") as out_file:
                tsv_writer = csv.writer(out_file, delimiter="\t")
                tsv_writer.writerow(["id", "smiles"])
                tsv_writer.writerow([input_cpd_SMILES, input_cpd_SMILES])
            return input_cpd_filepath
    # if the file exists, then just return its filepath
    else:
        return input_cpd_filepath

# Checked and tested (but try more rules)
def create_cpds_df_aft_expansion(pk: Pickaxe) -> pd.DataFrame:
    """
    Create and save compounds generated by Pickaxe as a Pandas Dataframe

    Parameters:
    - pk (minedatabase.pickaxe object): Pickaxe object generated earlier

    Returns:
    - compounds_df (Pandas DataFrame): Pandas Dataframe containing compounds and information such as ID, generation, SMILES, etc.

    """
    ID_list = []  # list to store compound IDs
    Type_list = [] # list to store compound type - "substrate", "coreactant" or "predicted"
    Generation_list = [] # list to store what generation compound was present in
    Formula_list = []  # list to store chemical formula of compound
    SMILES_list = []  # list to store compound SMILES

    for key in pk.compounds.keys():  # for each compound, store information in relevant lists
        ID_list.append(pk.compounds[key]["ID"])
        Type_list.append(pk.compounds[key]["Type"])
        Generation_list.append(pk.compounds[key]["Generation"])
        Formula_list.append(pk.compounds[key]["Formula"])
        SMILES_list.append(pk.compounds[key]["SMILES"])

    # Combine all lists into a Pandas Dataframe
    compounds_df = pd.DataFrame(
        {
            "ID": ID_list,
            "Type": Type_list,
            "Generation": Generation_list,
            "Formula": Formula_list,
            "SMILES": SMILES_list,
        }
    )

    return compounds_df

# Checked and tested
def run_pickaxe_if_single_reported_product(pos_rxn_entry: Dict[str, Union[str,List[str],int] ],
                                           coreactants_filepath: str,
                                           reported_substrate: str, # one compound as Pk cannot do bimolecular reactions
                                           reported_product: str,
                                           gen_rules_filepath: str) -> List[ Dict[str, Union[str,List[str],int]] ]:
    """
    Synthetically generate negative products using Pickaxe and the alternate reaction center hypothesis. This function
    can be used to generate negative, alternate products for mined reactions that have only one known reported product.

    With this function, a reaction entry or dictionary for a known, positive reaction (as labelled by thermodynamics)
    is taken in and then from this entry, the mapped reaction rule is extracted and saved as a .tsv file. Subsequently,
    the reported substrate, which is also an input argument for this function, is also saved as a .tsv file. With this
    single reported substrate and single reaction rule, a Pickaxe object is initialized and a 1-step metabolic expansion
    is run.

    After the expansion, all possible products are collected and from there, only unique products that do not
    share the same SMILES string as the reported products are saved. These are alternate products and their SMILES are
    saved only once all stereochemical information has been removed and the SMILES string has been canonicalized.

    For each unique, alternate product, a new reaction entry or dictionary is created an added to a list. This list
    containing reaction entries of all negative reactions is then returned as the output of this function.

    Parameters:
    - pos_rxn_entry ( Dict[ str, Union[str,List[str],int] ] ): Dictionary containing a processed, positive reaction entry

    - coreactants_filepath (str): String representing the cofactors that would be fed into Pickaxe. It actually does not
                                  matter if these cofactors have stereochemistry or not because we save the cofactors
                                  in the original reaction string, which would have already had its stereochemical
                                  information scrubbed

    - reported_substrate (str): SMILES string of the original substrate in canonical form and without stereochemistry.
                                If a known reaction exists wherein only one substrate gives one product, then we can
                                simply pass in the SMILES string of that one known substrate. If a known reaction exists,
                                however, wherein multiple substrates give one product, then alternate products will have
                                to be generated from each substrate one at a time since Pickaxe v2.0 does not handle
                                multisubstrate reactions

    - reported_product (str): SMILES string of the original product. Note that this function is only used to run Pickaxe
                              on known reactions for which exactly one product exists only

    - gen_rules_filepath (str): string representing the filepath to JN1224MIN

    Returns:
    - syn_gen_neg_data (List[ Dict[str, Union[str,List[str],int]] ]): List of synthetically generated negative rxns
    """

    # Check that only a thermodynamically feasible reaction is used to synthetically generate infeasible reactions
    assert pos_rxn_entry['feasibility_label'] == 1

    # check to ensure that only one product exists
    assert len(pos_rxn_entry['Products']) == 1

    # create .tsv file for the rule that this reported reaction has been mapped onto (should be exactly one rule)
    input_rule_filepath = select_rule_for_expansion(mapped_rule = pos_rxn_entry['Rule'],
                                                    gen_rules_filepath = gen_rules_filepath)

    # create .tsv file for the substrate that will be used in Pickaxe expansions to enumerate negative products
    input_cpd_filepath = create_tsv_for_input_cpd(input_cpd_SMILES = reported_substrate)

    # initialize Pickaxe object then run single-step metabolic expansion
    pk = Pickaxe(coreactant_list = coreactants_filepath, rule_list = input_rule_filepath)
    pk.load_compound_set(compound_file = input_cpd_filepath) # load starting compound
    pk.transform_all(processes = 100, generations = 1) # expand on this substrate for one step only

    # compile all possible products into a dataframe
    pickaxe_cpds_df = create_cpds_df_aft_expansion(pk)

    # extract all predicted products that are exactly 1 step away
    all_possible_products_df = pickaxe_cpds_df[ ( pickaxe_cpds_df['Type'] == 'Predicted') &
                                             ( pickaxe_cpds_df['Generation'] == int(1) ) ]

    all_possible_products = list(all_possible_products_df['SMILES'])

    # initialize a set to store the unique pickaxe-generated alternate products (i.e. no duplicates)
    alternate_products = set()

    # for each possible product generated, check which product was not experimentally observed in the reported reaction
    for possible_product in all_possible_products:

        # first, remove the stereochemistry of this possible product and canonicalize its SMILES
        compound_object = featurizations.compound(possible_product)
        possible_product = compound_object.remove_stereo()

        # if the canonical SMILES of this possible product after removing stereochem is not that of the reported product
        if possible_product != reported_product:

            # then an alternate product has been generated - so store this!
            alternate_products.add(possible_product)

    # create an empty list to store reaction entries of all synthetically generated negative reactions
    syn_gen_neg_data = []

    # now, iterate through the set of unique, synthetically generated alternate products, create entries, and store them
    for alternate_product in alternate_products:

        neg_rxn_entry = {
                "Original enzymatic database": pos_rxn_entry['Enzymatic database'],
                "Original reaction ID": pos_rxn_entry['Reaction ID'],
                "Original substrates": pos_rxn_entry['Substrates'],
                "Original products": pos_rxn_entry['Products'],

                # save the alternate product as a list
                # but recall that this function is only used for reaction rules that result in a single product
                "Alternate products": [alternate_product],
                "LHS_cofactors": pos_rxn_entry['LHS_cofactors'],
                "RHS_cofactors": pos_rxn_entry['RHS_cofactors'],


                "Reaction eq": preprocessing.construct_rxn_str( substrates = pos_rxn_entry['Substrates'],
                                                                lhs_cofactors = pos_rxn_entry['LHS_cofactors'],
                                                                products=[alternate_product],
                                                                rhs_cofactors = pos_rxn_entry['RHS_cofactors'] ),

                "Original rule": pos_rxn_entry['Rule'],

                "feasibility_label": 0, # synthetically generated reactions are always infeasible

                "remark": "alternate product from pos rxn" }

        syn_gen_neg_data.append(neg_rxn_entry)

    return syn_gen_neg_data

# Checked and tested
def run_pickaxe_if_multiple_reported_products(pos_rxn_entry: Dict[str, Union[str,List[str],int] ],
                                              coreactants_filepath: str,
                                              reported_substrate: str, # one compound as Pk cannot do bimolecular reactions
                                              reported_products: List[str], # this fn is for rxns w. multiple products
                                              gen_rules_filepath: str) -> List[ Dict[str, Union[str,List[str],int]] ]:

    # Check that multiple products exist
    assert len(reported_products) > 1

    # check that only a thermodynamically feasible reaction is being used to synthetically generate infeasible reactions
    assert pos_rxn_entry['feasibility_label'] == 1

    # create .tsv file for the rule that this reported reaction has been mapped onto (should be exactly one rule)
    input_rule_filepath = select_rule_for_expansion(mapped_rule=pos_rxn_entry['Rule'],
                                                    gen_rules_filepath=gen_rules_filepath)

    # create .tsv file for the substrate that will be used in Pickaxe expansions to enumerate negative products
    input_cpd_filepath = create_tsv_for_input_cpd(input_cpd_SMILES = reported_substrate)

    # initialize Pickaxe object then run single-step metabolic expansion
    pk = Pickaxe(coreactant_list=coreactants_filepath, rule_list=input_rule_filepath)
    pk.load_compound_set(compound_file=input_cpd_filepath)  # load starting compound
    pk.transform_all(processes=100, generations=1)  # expand on this substrate for one step only

    rxn_keys = None # initialize a value for reaction keys

    # extract reaction keys for all reactions involving this starting compound
    # i.e. we want all reactions in which this starting compound is a reactant in ("Reactant_in")
    for key in pk.compounds:
        if pk.compounds[key]["Type"] == "Starting Compound":
            rxn_keys = pk.compounds[key]["Reactant_in"]

    # create an empty list to store reaction entries of all synthetically generated negative reactions
    syn_gen_neg_data = []

    # for each reaction involving the reported substrate, check if this can be a synthetic infeasible reaction
    if rxn_keys:
        for key in rxn_keys:
            pickaxe_rxn_str = pk.reactions[key]["SMILES_rxn"]

            rxn_rhs = pickaxe_rxn_str.split(" => ")[1]  # products side (hence index 1) involving newly generated products
            products = rxn_rhs.split(" + ")  # on the products side, parse the string extract individual products

            # empty list to store products after removing their stereochemistry and canonicalizing SMILES
            cleaned_products = []

            for product_SMILES in products:
                # get the stoichiometry of this product ( first character in string, appears as '(2) CCO' for instance)
                product_stoichiometry = int(product_SMILES[1])

                # add product to list the same number of times as its stoichiometry (if stoichiometry is 2, add product 2x)
                # but remove the leading four stoichiometry characters from string (see above)
                for i in range(product_stoichiometry):
                    cleaned_products.append( featurizations.compound(product_SMILES[4:]).remove_stereo() )

            # check for intersections between generated products pairs and the original, reported product pair
            intersecting_list = list(set(cleaned_products) & set(reported_products))

            # if this intersection is either empty (i.e. no overlap at all between reported products and generated products)
            # or has fewer unique elements than the list of reported products (i.e. no exact overlap between reported products and generated products),
            # then a new, alternate pair of products has been generated that could have been possible but was never reported
            if intersecting_list == [] or len(intersecting_list) < len(set(reported_products)):

                neg_rxn_entry = {
                    "Original enzymatic database": pos_rxn_entry['Enzymatic database'],
                    "Original reaction ID": pos_rxn_entry['Reaction ID'],
                    "Original substrates": pos_rxn_entry['Substrates'],
                    "Original products": pos_rxn_entry['Products'],
                    "Alternate products": cleaned_products, # the cleaned products are the alternate products for this rxn
                    "LHS_cofactors": pos_rxn_entry['LHS_cofactors'],
                    "RHS_cofactors": pos_rxn_entry['RHS_cofactors'],

                    "Reaction eq": preprocessing.construct_rxn_str(substrates = [reported_substrate],
                                                              lhs_cofactors = pos_rxn_entry['LHS_cofactors'],
                                                              products = cleaned_products,
                                                              rhs_cofactors = pos_rxn_entry['RHS_cofactors']),

                    "Original rule": pos_rxn_entry['Rule'],

                    "feasibility_label": 0, # synthetically generated reactions are always infeasible

                    "remark": "alternate product from pos rxn"}

                syn_gen_neg_data.append(neg_rxn_entry)

    return syn_gen_neg_data

# Checked and tested but want to write more tests
def run_pickaxe_for_dimerization_rxns(pos_rxn_entry: Dict[str, Union[str,List[str],int] ],
                                      coreactants_filepath: str,
                                      reported_substrate: str,
                                      reported_products: List[str],
                                      gen_rules_filepath: str) -> List[ Dict[str, Union[str,List[str],int]] ]:

    # Check that multiple substrates exist
    # but note that even though we are checking this, Pickaxe only allows expansions on one substrate at a time
    assert len(pos_rxn_entry['Substrates']) > 1

    # check that only a thermodynamically feasible reaction is being used to synthetically generate infeasible reactions
    assert pos_rxn_entry['feasibility_label'] == 1

    # create .tsv file for the rule that this reported reaction has been mapped onto (should be exactly one rule)
    input_rule_filepath = select_rule_for_expansion(mapped_rule = pos_rxn_entry['Rule'],
                                                    gen_rules_filepath = gen_rules_filepath)

    # create .tsv file for the substrate that will be used in Pickaxe expansions to enumerate negative products
    input_cpd_filepath = create_tsv_for_input_cpd(input_cpd_SMILES = reported_substrate)

    # initialize Pickaxe object then run single-step metabolic expansion
    pk = Pickaxe(coreactant_list=coreactants_filepath, rule_list=input_rule_filepath)
    pk.load_compound_set(compound_file=input_cpd_filepath)  # load starting compound
    pk.transform_all(processes=100, generations=1)  # expand on this substrate for one step only

    rxn_keys = None  # initialize a value for reaction keys

    # extract reaction keys for all reactions involving this starting compound
    # i.e. we want all reactions in which this starting compound is a reactant in ("Reactant_in")
    for key in pk.compounds:
        if pk.compounds[key]["Type"] == "Starting Compound":
            rxn_keys = pk.compounds[key]["Reactant_in"]

    # create an empty reaction list to store reaction entries of all synthetically generated negative reactions
    syn_gen_neg_data = []

    # for each reaction involving the reported substrate, check if this can be a synthetic infeasible reaction
    if rxn_keys:
        for key in rxn_keys:
            pickaxe_rxn_str = pk.reactions[key]["SMILES_rxn"]

            rxn_lhs = pickaxe_rxn_str.split(" => ")[0] # substrates side (hence index 0)
            rxn_rhs = pickaxe_rxn_str.split(" => ")[1]  # products side (hence index 1) involving newly generated products

            reactants = rxn_lhs.split(" + ") # extract individual substrates from the substrates side
            products = rxn_rhs.split(" + ")  # on the products side, parse the string extract individual products

            # empty list to store products after removing their stereochemistry and canonicalizing SMILES
            cleaned_products = []

            # initialize a new reaction string to write the alternate reaction equation
            cleaned_rxn_str = ""

            # first, insert reactant SMILES string into the new reaction string
            for reactant_SMILES in reactants:
                # get the stoichiometry of this reactant ( first character in string, appears as '(2) CCO' for instance)
                reactant_stoich = int(reactant_SMILES[1])

                # add the reactant SMILES to the reaction string as many times as its stoichiometry
                # ensure reactant SMILES are canonicalized and that stereochemistry is removed along the way
                for i in range(reactant_stoich):
                    cleaned_rxn_str += featurizations.compound(reactant_SMILES[4:]).remove_stereo()
                    cleaned_rxn_str += " + "

            cleaned_rxn_str = cleaned_rxn_str.rstrip(" + ")  # remove extra ' + ' after adding the last reactant SMILES
            cleaned_rxn_str += " = "  # insert this before switching over to the products side

            for product_SMILES in products:
                # get the stoichiometry of this product ( first character in string, appears as '(2) CCO' for instance)
                product_stoich = int(product_SMILES[1])

                # add product to list the same number of times as its stoichiometry (if stoichiometry is 2, add product 2x)
                # but remove the leading four stoichiometry characters from string (see above)
                for i in range(product_stoich):
                    cleaned_rxn_str += featurizations.compound(product_SMILES[4:]).remove_stereo()
                    cleaned_rxn_str += " + "
                    cleaned_products.append(featurizations.compound(product_SMILES[4:]).remove_stereo())

            cleaned_rxn_str = cleaned_rxn_str.rstrip(" + ")  # remove extra ' + ' after adding the last product SMILES

            # check for intersections between generated products pairs and the original, reported product pair
            intersecting_list = list(set(cleaned_products) & set(reported_products))

            # if this intersection is either empty (i.e. no overlap at all between reported products and generated products)
            # or has fewer unique elements than the list of reported products (i.e. no exact overlap between reported products and generated products),
            # then a new, alternate pair of products has been generated that could have been possible but was never reported
            if intersecting_list == [] or len(intersecting_list) < len(set(reported_products)):
                neg_rxn_entry = {
                    "Original enzymatic database": pos_rxn_entry['Enzymatic database'],
                    "Original reaction ID": pos_rxn_entry['Reaction ID'],
                    "Original substrates": pos_rxn_entry['Substrates'],
                    "Original products": pos_rxn_entry['Products'],
                    "Alternate products": cleaned_products,  # the cleaned products are the alternate products for this rxn
                    "LHS_cofactors": pos_rxn_entry['LHS_cofactors'],
                    "RHS_cofactors": pos_rxn_entry['RHS_cofactors'],

                    "Reaction eq": cleaned_rxn_str,

                    "Original rule": pos_rxn_entry['Rule'],

                    "feasibility_label": 0,  # synthetically generated reactions are always infeasible

                    "remark": "alternate product from pos rxn"}

                syn_gen_neg_data.append(neg_rxn_entry)

    return syn_gen_neg_data

# ----- all rxn rules -------
def run_pickaxe_if_single_reported_product_all_rxn_rules(pos_rxn_entry: Dict[str, Union[str,List[str],int] ],
                                                           coreactants_filepath: str,
                                                           reported_substrate: str, # one compound as Pk cannot do bimolecular reactions
                                                           reported_product: str,
                                                           gen_rules_filepath: str) -> List[ Dict[str, Union[str,List[str],int]] ]:
                    """
                    Synthetically generate negative products using Pickaxe and the alternate reaction center hypothesis. This function
                    can be used to generate negative, alternate products for mined reactions that have only one known reported product.

                    With this function, a reaction entry or dictionary for a known, positive reaction (as labelled by thermodynamics)
                    is taken in and then from this entry, the mapped reaction rule is extracted and saved as a .tsv file. Subsequently,
                    the reported substrate, which is also an input argument for this function, is also saved as a .tsv file. With this
                    single reported substrate and single reaction rule, a Pickaxe object is initialized and a 1-step metabolic expansion
                    is run.

                    After the expansion, all possible products are collected and from there, only unique products that do not
                    share the same SMILES string as the reported products are saved. These are alternate products and their SMILES are
                    saved only once all stereochemical information has been removed and the SMILES string has been canonicalized.

                    For each unique, alternate product, a new reaction entry or dictionary is created an added to a list. This list
                    containing reaction entries of all negative reactions is then returned as the output of this function.

                    Parameters:
                    - pos_rxn_entry ( Dict[ str, Union[str,List[str],int] ] ): Dictionary containing a processed, positive reaction entry

                    - coreactants_filepath (str): String representing the cofactors that would be fed into Pickaxe. It actually does not
                                                  matter if these cofactors have stereochemistry or not because we save the cofactors
                                                  in the original reaction string, which would have already had its stereochemical
                                                  information scrubbed

                    - reported_substrate (str): SMILES string of the original substrate in canonical form and without stereochemistry.
                                                If a known reaction exists wherein only one substrate gives one product, then we can
                                                simply pass in the SMILES string of that one known substrate. If a known reaction exists,
                                                however, wherein multiple substrates give one product, then alternate products will have
                                                to be generated from each substrate one at a time since Pickaxe v2.0 does not handle
                                                multisubstrate reactions

                    - reported_product (str): SMILES string of the original product. Note that this function is only used to run Pickaxe
                                              on known reactions for which exactly one product exists only

                    - gen_rules_filepath (str): string representing the filepath to JN1224MIN

                    Returns:
                    - syn_gen_neg_data (List[ Dict[str, Union[str,List[str],int]] ]): List of synthetically generated negative rxns
                    """

                    # Check that only a thermodynamically feasible reaction is used to synthetically generate infeasible reactions
                    assert pos_rxn_entry['feasibility_label'] == 1

                    # check to ensure that only one product exists
                    assert len(pos_rxn_entry['Products']) == 1

                    # create .tsv file for the substrate that will be used in Pickaxe expansions to enumerate negative products
                    input_cpd_filepath = create_tsv_for_input_cpd(input_cpd_SMILES = reported_substrate)

                    # initialize Pickaxe object then run single-step metabolic expansion
                    pk = Pickaxe(coreactant_list = coreactants_filepath, rule_list = gen_rules_filepath)
                    pk.load_compound_set(compound_file = input_cpd_filepath) # load starting compound
                    pk.transform_all(processes = 100, generations = 1) # expand on this substrate for one step only

                    # compile all possible products into a dataframe
                    pickaxe_cpds_df = create_cpds_df_aft_expansion(pk)

                    # extract all predicted products that are exactly 1 step away
                    all_possible_products_df = pickaxe_cpds_df[ ( pickaxe_cpds_df['Type'] == 'Predicted') &
                                                             ( pickaxe_cpds_df['Generation'] == int(1) ) ]

                    all_possible_products = list(all_possible_products_df['SMILES'])

                    # initialize a set to store the unique pickaxe-generated alternate products (i.e. no duplicates)
                    alternate_products = set()

                    # for each possible product generated, check which product was not experimentally observed in the reported reaction
                    for possible_product in all_possible_products:

                        # first, remove the stereochemistry of this possible product and canonicalize its SMILES
                        compound_object = featurizations.compound(possible_product)
                        possible_product = compound_object.remove_stereo()

                        # if the canonical SMILES of this possible product after removing stereochem is not that of the reported product
                        if possible_product != reported_product:

                            # then an alternate product has been generated - so store this!
                            alternate_products.add(possible_product)

                    # create an empty list to store reaction entries of all synthetically generated negative reactions
                    syn_gen_neg_data = []

                    # now, iterate through the set of unique, synthetically generated alternate products, create entries, and store them
                    for alternate_product in alternate_products:

                        neg_rxn_entry = {
                                "Original enzymatic database": pos_rxn_entry['Enzymatic database'],
                                "Original reaction ID": pos_rxn_entry['Reaction ID'],
                                "Original substrates": pos_rxn_entry['Substrates'],
                                "Original products": pos_rxn_entry['Products'],

                                # save the alternate product as a list
                                # but recall that this function is only used for reaction rules that result in a single product
                                "Alternate products": [alternate_product],
                                "LHS_cofactors": pos_rxn_entry['LHS_cofactors'],
                                "RHS_cofactors": pos_rxn_entry['RHS_cofactors'],


                                "Reaction eq": preprocessing.construct_rxn_str( substrates = pos_rxn_entry['Substrates'],
                                                                                lhs_cofactors = pos_rxn_entry['LHS_cofactors'],
                                                                                products=[alternate_product],
                                                                                rhs_cofactors = pos_rxn_entry['RHS_cofactors'] ),

                                "Original rule": pos_rxn_entry['Rule'],

                                "feasibility_label": 0, # synthetically generated reactions are always infeasible

                                "remark": "alternate product from pos rxn" }

                        syn_gen_neg_data.append(neg_rxn_entry)

                    return syn_gen_neg_data

# Checked and tested
def run_pickaxe_if_multiple_reported_products_all_rxn_rules(pos_rxn_entry: Dict[str, Union[str,List[str],int] ],
                                                              coreactants_filepath: str,
                                                              reported_substrate: str, # one compound as Pk cannot do bimolecular reactions
                                                              reported_products: List[str], # this fn is for rxns w. multiple products
                                                              gen_rules_filepath: str) -> List[ Dict[str, Union[str,List[str],int]] ]:

                    # check that only a thermodynamically feasible reaction is being used to synthetically generate infeasible reactions
                    assert pos_rxn_entry['feasibility_label'] == 1

                    # create .tsv file for the substrate that will be used in Pickaxe expansions to enumerate negative products
                    input_cpd_filepath = create_tsv_for_input_cpd(input_cpd_SMILES = reported_substrate)

                    # initialize Pickaxe object then run single-step metabolic expansion
                    pk = Pickaxe(coreactant_list=coreactants_filepath, rule_list=gen_rules_filepath)
                    pk.load_compound_set(compound_file=input_cpd_filepath)  # load starting compound
                    pk.transform_all(processes=100, generations=1)  # expand on this substrate for one step only

                    rxn_keys = None # initialize a value for reaction keys

                    # extract reaction keys for all reactions involving this starting compound
                    # i.e. we want all reactions in which this starting compound is a reactant in ("Reactant_in")
                    for key in pk.compounds:
                        if pk.compounds[key]["Type"] == "Starting Compound":
                            rxn_keys = pk.compounds[key]["Reactant_in"]

                    # create an empty list to store reaction entries of all synthetically generated negative reactions
                    syn_gen_neg_data = []

                    # for each reaction involving the reported substrate, check if this can be a synthetic infeasible reaction
                    if rxn_keys:
                        for key in rxn_keys:
                            pickaxe_rxn_str = pk.reactions[key]["SMILES_rxn"]

                            rxn_rhs = pickaxe_rxn_str.split(" => ")[1]  # products side (hence index 1) involving newly generated products
                            products = rxn_rhs.split(" + ")  # on the products side, parse the string extract individual products

                            # empty list to store products after removing their stereochemistry and canonicalizing SMILES
                            cleaned_products = []

                            for product_SMILES in products:
                                # get the stoichiometry of this product ( first character in string, appears as '(2) CCO' for instance)
                                product_stoichiometry = int(product_SMILES[1])

                                # add product to list the same number of times as its stoichiometry (if stoichiometry is 2, add product 2x)
                                # but remove the leading four stoichiometry characters from string (see above)
                                for i in range(product_stoichiometry):
                                    cleaned_products.append( featurizations.compound(product_SMILES[4:]).remove_stereo() )

                            # check for intersections between generated products pairs and the original, reported product pair
                            intersecting_list = list(set(cleaned_products) & set(reported_products))

                            # if this intersection is either empty (i.e. no overlap at all between reported products and generated products)
                            # or has fewer unique elements than the list of reported products (i.e. no exact overlap between reported products and generated products),
                            # then a new, alternate pair of products has been generated that could have been possible but was never reported
                            if intersecting_list == [] or len(intersecting_list) < len(set(reported_products)):

                                neg_rxn_entry = {
                                    "Original enzymatic database": pos_rxn_entry['Enzymatic database'],
                                    "Original reaction ID": pos_rxn_entry['Reaction ID'],
                                    "Original substrates": pos_rxn_entry['Substrates'],
                                    "Original products": pos_rxn_entry['Products'],
                                    "Alternate products": cleaned_products, # the cleaned products are the alternate products for this rxn
                                    "LHS_cofactors": pos_rxn_entry['LHS_cofactors'],
                                    "RHS_cofactors": pos_rxn_entry['RHS_cofactors'],

                                    "Reaction eq": preprocessing.construct_rxn_str(substrates = [reported_substrate],
                                                                              lhs_cofactors = pos_rxn_entry['LHS_cofactors'],
                                                                              products = cleaned_products,
                                                                              rhs_cofactors = pos_rxn_entry['RHS_cofactors']),

                                    "Original rule": pos_rxn_entry['Rule'],

                                    "feasibility_label": 0, # synthetically generated reactions are always infeasible

                                    "remark": "alternate product from pos rxn"}

                                syn_gen_neg_data.append(neg_rxn_entry)

                    return syn_gen_neg_data

# Checked and tested but want to write more tests
def run_pickaxe_for_dimerization_rxns_all_rxn_rules(pos_rxn_entry: Dict[str, Union[str,List[str],int] ],
                                      coreactants_filepath: str,
                                      reported_substrate: str,
                                      reported_products: List[str],
                                      gen_rules_filepath: str) -> List[ Dict[str, Union[str,List[str],int]] ]:

    # Check that multiple substrates exist
    # but note that even though we are checking this, Pickaxe only allows expansions on one substrate at a time
    assert len(pos_rxn_entry['Substrates']) > 1

    # check that only a thermodynamically feasible reaction is being used to synthetically generate infeasible reactions
    assert pos_rxn_entry['feasibility_label'] == 1

    # create .tsv file for the substrate that will be used in Pickaxe expansions to enumerate negative products
    input_cpd_filepath = create_tsv_for_input_cpd(input_cpd_SMILES = reported_substrate)

    # initialize Pickaxe object then run single-step metabolic expansion
    pk = Pickaxe(coreactant_list=coreactants_filepath, rule_list=gen_rules_filepath)
    pk.load_compound_set(compound_file=input_cpd_filepath)  # load starting compound
    pk.transform_all(processes=100, generations=1)  # expand on this substrate for one step only

    rxn_keys = None  # initialize a value for reaction keys

    # extract reaction keys for all reactions involving this starting compound
    # i.e. we want all reactions in which this starting compound is a reactant in ("Reactant_in")
    for key in pk.compounds:
        if pk.compounds[key]["Type"] == "Starting Compound":
            rxn_keys = pk.compounds[key]["Reactant_in"]

    # create an empty reaction list to store reaction entries of all synthetically generated negative reactions
    syn_gen_neg_data = []

    # for each reaction involving the reported substrate, check if this can be a synthetic infeasible reaction
    if rxn_keys:
        for key in rxn_keys:
            pickaxe_rxn_str = pk.reactions[key]["SMILES_rxn"]

            rxn_lhs = pickaxe_rxn_str.split(" => ")[0] # substrates side (hence index 0)
            rxn_rhs = pickaxe_rxn_str.split(" => ")[1]  # products side (hence index 1) involving newly generated products

            reactants = rxn_lhs.split(" + ") # extract individual substrates from the substrates side
            products = rxn_rhs.split(" + ")  # on the products side, parse the string extract individual products

            # empty list to store products after removing their stereochemistry and canonicalizing SMILES
            cleaned_products = []

            # initialize a new reaction string to write the alternate reaction equation
            cleaned_rxn_str = ""

            # first, insert reactant SMILES string into the new reaction string
            for reactant_SMILES in reactants:
                # get the stoichiometry of this reactant ( first character in string, appears as '(2) CCO' for instance)
                reactant_stoich = int(reactant_SMILES[1])

                # add the reactant SMILES to the reaction string as many times as its stoichiometry
                # ensure reactant SMILES are canonicalized and that stereochemistry is removed along the way
                for i in range(reactant_stoich):
                    cleaned_rxn_str += featurizations.compound(reactant_SMILES[4:]).remove_stereo()
                    cleaned_rxn_str += " + "

            cleaned_rxn_str = cleaned_rxn_str.rstrip(" + ")  # remove extra ' + ' after adding the last reactant SMILES
            cleaned_rxn_str += " = "  # insert this before switching over to the products side

            for product_SMILES in products:
                # get the stoichiometry of this product ( first character in string, appears as '(2) CCO' for instance)
                product_stoich = int(product_SMILES[1])

                # add product to list the same number of times as its stoichiometry (if stoichiometry is 2, add product 2x)
                # but remove the leading four stoichiometry characters from string (see above)
                for i in range(product_stoich):
                    cleaned_rxn_str += featurizations.compound(product_SMILES[4:]).remove_stereo()
                    cleaned_rxn_str += " + "
                    cleaned_products.append(featurizations.compound(product_SMILES[4:]).remove_stereo())

            cleaned_rxn_str = cleaned_rxn_str.rstrip(" + ")  # remove extra ' + ' after adding the last product SMILES

            # check for intersections between generated products pairs and the original, reported product pair
            intersecting_list = list(set(cleaned_products) & set(reported_products))

            # if this intersection is either empty (i.e. no overlap at all between reported products and generated products)
            # or has fewer unique elements than the list of reported products (i.e. no exact overlap between reported products and generated products),
            # then a new, alternate pair of products has been generated that could have been possible but was never reported
            if intersecting_list == [] or len(intersecting_list) < len(set(reported_products)):
                neg_rxn_entry = {
                    "Original enzymatic database": pos_rxn_entry['Enzymatic database'],
                    "Original reaction ID": pos_rxn_entry['Reaction ID'],
                    "Original substrates": pos_rxn_entry['Substrates'],
                    "Original products": pos_rxn_entry['Products'],
                    "Alternate products": cleaned_products,  # the cleaned products are the alternate products for this rxn
                    "LHS_cofactors": pos_rxn_entry['LHS_cofactors'],
                    "RHS_cofactors": pos_rxn_entry['RHS_cofactors'],

                    "Reaction eq": cleaned_rxn_str,

                    "Original rule": pos_rxn_entry['Rule'],

                    "feasibility_label": 0,  # synthetically generated reactions are always infeasible

                    "remark": "alternate product from pos rxn"}

                syn_gen_neg_data.append(neg_rxn_entry)

    return syn_gen_neg_data